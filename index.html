<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>countingstars</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="countingstars">
<meta property="og:url" content="https://blog.countingstars.cc/index.html">
<meta property="og:site_name" content="countingstars">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Lios">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="countingstars" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">countingstars</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"
          ><span class="fa fa-bars"></span
        ></a>
        
        <a class="main-nav-link" href="/"
          >Home</a
        >
        
        <a class="main-nav-link" href="/archives"
          >Archives</a
        >
        
      </nav>
      <nav id="sub-nav">
          
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://blog.countingstars.cc"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-动态规划（资源优化版）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E8%B5%84%E6%BA%90%E4%BC%98%E5%8C%96%E7%89%88%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2024-09-03T14:31:55.000Z" itemprop="datePublished">2024-09-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E8%B5%84%E6%BA%90%E4%BC%98%E5%8C%96%E7%89%88%EF%BC%89/">动态规划（资源优化版）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ul>
<li>有限的资源组合出尽可能大的答案，答案关于资源数单调不减，这里的单调不减指的是资源越多答案只可能越优，不可能变差</li>
</ul>
<h2 id="线性-dp（基础版）"><a href="#线性-dp（基础版）" class="headerlink" title="线性 dp（基础版）"></a>线性 dp（基础版）</h2><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul>
<li>只在一个维度资源有限，另外的维度视作无限资源</li>
</ul>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ul>
<li>资源从小到大递推</li>
<li>求出转移方程</li>
</ul>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="1、牛吃草问题"><a href="#1、牛吃草问题" class="headerlink" title="1、牛吃草问题"></a>1、牛吃草问题</h4><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p>有 n 块草地坐标范围 L<del>i</del>-R<del>i</del>，每块草地有 R<del>i</del>-L<del>i</del>+1 份草，不能选择有重叠区域的草地，最多能吃多少草？</p>
<h5 id="代码逻辑"><a href="#代码逻辑" class="headerlink" title="代码逻辑"></a>代码逻辑</h5><ul>
<li>有限的资源（n 块草地）吃到尽可能多的草，草地变多，答案单调不减</li>
<li>只要有草就能吃，容量无限</li>
<li>吃草的终点坐标从小到大递推，那么资源也就从小到大递推</li>
<li>dp[i]&gt;dp[j]当且仅当 dp[i]中选择了右端点处于 j+1 到 i 的草地</li>
<li>状态转移时，尽可能从近的状态转移（因为答案关于资源单调不减）</li>
<li>选 i 为终点的草地，转移方程见 for 循环, 不选 i 为终点的草地，转移方程 dp[i]&#x3D;dp[i-1]，两者选择一个答案最优的</li>
</ul>
<h5 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; right_left[maxn];</span><br><span class="line"><span class="comment">//对于每一个右端点，存下它的所有左端点,right的下标表示右端点，对应的容器中的值表示与此右端点对应的左端点</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=right_max;i++) <span class="comment">//right_max为数据中最大的右端点</span></span><br><span class="line">   &#123;</span><br><span class="line">    	   dp[i] = dp[i<span class="number">-1</span>]; <span class="comment">//不选以i为终点的草地</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> ver : right_left[i])</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">if</span>(dp[ver<span class="number">-1</span>] + i - ver + <span class="number">1</span> &gt; dp[i] )</span><br><span class="line">                  dp[i] = dp[ver<span class="number">-1</span>] + i - ver + <span class="number">1</span>;</span><br><span class="line">   <span class="comment">//如果dp[i]从下标ver到i-1的dp值转移而来，这个dp值要么等于dp[ver-1]，要么这个dp值对应的状态和当下冲突</span></span><br><span class="line">          &#125;</span><br><span class="line">   &#125;</span><br><span class="line">cout&lt;&lt;dp[right_max];</span><br></pre></td></tr></table></figure>

<h4 id="2、物品摆放问题"><a href="#2、物品摆放问题" class="headerlink" title="2、物品摆放问题"></a>2、物品摆放问题</h4><h5 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h5><p>有 n 个位置可以摆放物品，物品无限，但要求两者之间至少有 k 个空位，什么物品都不摆放也算一种方案，一共有多少种摆放方案？</p>
<h5 id="代码逻辑-1"><a href="#代码逻辑-1" class="headerlink" title="代码逻辑"></a>代码逻辑</h5><ul>
<li>有限的资源（n 个位置）求尽可能多的摆放方案，位置变多，答案单调不减</li>
<li>只要有合法位置就能摆物品，物品无限</li>
<li>摆放物品的终点从小到大递推，那么资源也就从小到大递推</li>
<li>第 n 个位置要么摆放物品要么不摆放物品，两种对应的情况数相加得到答案</li>
</ul>
<h5 id="核心代码-1"><a href="#核心代码-1" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//只考虑0个位置，即什么都不放</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">   &#123;</span><br><span class="line">       dp[i] = dp[i<span class="number">-1</span>]; <span class="comment">//第i个位置不摆放物品</span></span><br><span class="line">       <span class="comment">//加上第i个位置摆放物品的方案</span></span><br><span class="line">       dp[i] += i-k<span class="number">+1</span>&gt;<span class="number">0</span> ? dp[i-k<span class="number">+1</span>] : <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//i-k+1&lt;=0时，只有前面什么物品都不放才能在i这里放物品，只加一种情况</span></span><br><span class="line">  <span class="comment">//i-k+1&gt;0时，从i-k+2到i-1必然都没有物品且第i位有物品，后面定了，所以前面有多少种方案就加多少种方案</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="滚动数组"><a href="#滚动数组" class="headerlink" title="滚动数组"></a>滚动数组</h2><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ul>
<li>有限的资源和有限的容量组合出尽可能大的结果，相同的资源条件下，结果随容量单调不减，但各结果无递归关系，当下结果只与前一个资源条件下的结果有关</li>
</ul>
<h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><h4 id="1、奇怪的数列"><a href="#1、奇怪的数列" class="headerlink" title="1、奇怪的数列"></a>1、奇怪的数列</h4><h5 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h5><p>n 个数字构成和为 s 的数列，其中 a<del>i</del>只能加 a 或者减 b 到 a<del>i+1</del>，求满足条件的数列有多少个</p>
<h5 id="代码逻辑-2"><a href="#代码逻辑-2" class="headerlink" title="代码逻辑"></a>代码逻辑</h5><ul>
<li>把+a 和-b 都视作+P</li>
<li>求和时，a<del>0</del>-a<del>n-1</del>的+P 的权重为 0 到 n-1，$$\sum_{i&#x3D;0}^{n-1}$$a<del>i</del> &#x3D; na<del>0</del>+$$\frac{n(n-1)P}{2}$$，$$\frac{n(n-1)}{2}$$里面有 i 次是+a 时，权重分配方案为 dp<del>i</del>,各种分配方案求出来的 a<del>0</del>是定值，如果是整数，那么答案加 dp<del>i</del>，否则，答案加 0</li>
<li>有限的资源（n 个数列元素），有限的容量（分配给+a 的权重至多为$$\frac{n(n-1)}{2}$$,这里 n 表示当下资源规模）外循环表示资源从小到大</li>
<li>dp<del>ij</del>&#x3D;dp<del>(i-1)j</del>+dp<del>(i-1)(j-i)</del>，把第一层维度放到外循环上</li>
</ul>
<h5 id="核心代码-2"><a href="#核心代码-2" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>]=<span class="number">1</span>; <span class="comment">//规模为1时，无权重可分，只有dp[0]为1，其他为0</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) <span class="comment">//问题规模为1+i，终点为下标为i的数列元素</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">//滚动数组先默认继承了上一个状态的值，相当于i号元素权重不给+a的方案数</span></span><br><span class="line">       <span class="comment">//然后再加上i号元素的权重赋给+a的方案数</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> j=(i<span class="number">+1</span>)*i/<span class="number">2</span>;j&gt;=i;j--)</span><br><span class="line">           dp[j] += dp[j-i]; <span class="comment">//如果j本身小于i，那么i号元素权重赋给+a的方案数为0，也就是dp[j]+=0</span></span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n*(n<span class="number">-1</span>)/<span class="number">2</span>;i++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="type">int</span> a0 = s + b * ( n*(n<span class="number">-1</span>)/<span class="number">2</span> - i ) - a * i ;</span><br><span class="line">       <span class="keyword">if</span> (a0%n==<span class="number">0</span>)</span><br><span class="line">           ans += dp[i];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、背包问题（基础版）"><a href="#2、背包问题（基础版）" class="headerlink" title="2、背包问题（基础版）"></a>2、背包问题（基础版）</h4><h5 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h5><p>有一个容量 V 的背包，有 n 个物品体积分别为 v<del>i</del>，求出背包用掉的最大容量</p>
<h5 id="代码逻辑-3"><a href="#代码逻辑-3" class="headerlink" title="代码逻辑"></a>代码逻辑</h5><ul>
<li>有限资源（n 个物品），有限容量（V）要求组合出尽可能大的体积</li>
<li>dp<del>ij</del>&#x3D;dp<del>(i-1)j</del>+dp<del>(i-1)(j-v)</del>+v 可以把第一维度体现在外循环上</li>
<li>状态转移时，用尽可能贴近的 dp 值做转移，因为答案单调不减</li>
</ul>
<h5 id="核心代码-3"><a href="#核心代码-3" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)  <span class="comment">//考虑前i件物品</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">//默认第i件物品不放入</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> j=V;j&gt;=V-v[i];j--)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">//如果第i件物品可以放入，且放入结果更大，就放入</span></span><br><span class="line">           <span class="keyword">if</span>( dp[j] &lt; dp[ j - v[i] ] + v[i] )</span><br><span class="line">               dp[j] = dp[ j - v[i] ] + v[i];</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3、多重背包"><a href="#3、多重背包" class="headerlink" title="3、多重背包"></a>3、多重背包</h4><h5 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h5><p>背包有 V 容量，n 种商品分别有价值量 w<del>i</del>，体积 v<del>i</del>和数量 s<del>i</del>，求出背包可以装下的最大价值</p>
<h5 id="代码逻辑-4"><a href="#代码逻辑-4" class="headerlink" title="代码逻辑"></a>代码逻辑</h5><ul>
<li>有限的资源（n 种商品），有限的容量（背包容量 V）求出尽可能大的价值量</li>
<li>dp<del>ij</del>&#x3D;dp<del>(i-1)j</del>+dp<del>(i-1)(j-v)</del>+w 可以把第一维度体现在外循环上</li>
<li>外循环表示物品种类一件件增加，问题规模从小到大</li>
<li>每考虑一种商品需要考虑 s<del>i</del>次状态转移，把 s<del>i</del>二进制分解，减少计算次数</li>
</ul>
<h5 id="核心代码-4"><a href="#核心代码-4" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">   &#123;</span><br><span class="line">       cin&gt;&gt;w&gt;&gt;v&gt;&gt;s;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=s;s-=j,j+=j) <span class="comment">// 每次循环代表的物品体积j*v，价值j*w</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">//默认这件物品不放入</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> k=V;k&gt;=j*v;k--)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="comment">//如果这件物品可以放入，且放入结果更大，就放入</span></span><br><span class="line">               <span class="keyword">if</span>(dp[k] &lt; dp[k-j*v] + j * w)</span><br><span class="line">                   dp[k] = dp[k-j*v] + j * w;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(s&gt;<span class="number">0</span>)  <span class="comment">//s未被分尽</span></span><br><span class="line">       &#123;</span><br><span class="line">    		<span class="keyword">for</span>(<span class="type">int</span> k=V;k&gt;=s*v;k--)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">if</span>(dp[k] &lt; dp[k-s*v] + s * w)</span><br><span class="line">                   dp[k] = dp[k-s*v] + s * w;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="背包问题拓展"><a href="#背包问题拓展" class="headerlink" title="背包问题拓展"></a>背包问题拓展</h2><h3 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h3><h4 id="1、完全背包"><a href="#1、完全背包" class="headerlink" title="1、完全背包"></a>1、完全背包</h4><h5 id="问题描述-5"><a href="#问题描述-5" class="headerlink" title="问题描述"></a>问题描述</h5><p>背包容量 V，n 种商品具有价值量 w<del>i</del>和体积 v<del>i</del>，每种商品都可以无限次购买，求背包装下的最大价值</p>
<h5 id="代码逻辑-5"><a href="#代码逻辑-5" class="headerlink" title="代码逻辑"></a>代码逻辑</h5><ul>
<li>有限的资源（n 种商品），有限的容量（背包容量 V），组成尽可能大的价值</li>
<li>dp<del>ij</del>&#x3D;dp<del>(i-1)j</del>(j&lt;v<del>i</del>)，dp<del>ij</del>&#x3D;max(dp<del>ij</del> , dp<del>i(j-vi)</del>+w<del>i</del>) 先用外循环继承上一个状态的结果，再用内循环从前向后递推</li>
</ul>
<h5 id="核心代码-5"><a href="#核心代码-5" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> j=v[i];j&lt;=V;j++)</span><br><span class="line">       &#123;</span><br><span class="line">        	dp[j] = <span class="built_in">max</span>(dp[j],dp[ j - v[i] ] + w[i])</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="二维-dp"><a href="#二维-dp" class="headerlink" title="二维 dp"></a>二维 dp</h2><h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h3><p>状态转移时，必须考虑两个维度</p>
<h3 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h3><h4 id="1、砝码称重"><a href="#1、砝码称重" class="headerlink" title="1、砝码称重"></a>1、砝码称重</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>N 个砝码分别重 W<del>i</del>，求出最多可以称量多少种重量</p>
<h5 id="代码逻辑-6"><a href="#代码逻辑-6" class="headerlink" title="代码逻辑"></a>代码逻辑</h5><ul>
<li>如果只用一维数组，那么 dp<del>i</del>能表示的信息只有前 i 个砝码可以称出多少种重量，但是考虑状态转移的时候发现，由于不知道到底具体哪些重量可以被称出来，所以无法排重。比如 dp<del>i</del>&#x3D;3 时，如果四个砝码可以称出重量 10，无法确定 dp<del>4</del>应该比 dp<del>3</del>大还是和 dp<del>3</del>一样大</li>
<li>用二维数组 dp<del>ij</del>表示前 i 个砝码是否可以称出重量 j</li>
</ul>
<h5 id="核心代码-6"><a href="#核心代码-6" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="comment">//资源从小到大遍历</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=sumW;j&gt;=<span class="number">1</span>;j--)</span><br><span class="line">      &#123;</span><br><span class="line">         	<span class="keyword">if</span>(dp[i<span class="number">-1</span>][j]) <span class="comment">//继承</span></span><br><span class="line">              dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">         	<span class="keyword">else</span> <span class="keyword">if</span>(j==w[i]) <span class="comment">//只用i这个砝码</span></span><br><span class="line">              dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>(dp][i<span class="number">-1</span>][ j + w[i] ]) <span class="comment">//第i个砝码和物品在天平同一边</span></span><br><span class="line">              dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">          <span class="comment">//第i个砝码与物品分别在天平的两边</span></span><br><span class="line">         	<span class="keyword">else</span> <span class="keyword">if</span>(j&lt;w[i] &amp;&amp; dp[i<span class="number">-1</span>][ w[i] - j ])</span><br><span class="line">              dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>(j&gt;w[i] &amp;&amp; dp[i<span class="number">-1</span>][ j - w[i] ])</span><br><span class="line">              dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="状态压缩-dp"><a href="#状态压缩-dp" class="headerlink" title="状态压缩 dp"></a>状态压缩 dp</h2><h3 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h3><p>总状态数不多，可以用二进制表示</p>
<h3 id="例题-4"><a href="#例题-4" class="headerlink" title="例题"></a>例题</h3><h4 id="1、买糖果"><a href="#1、买糖果" class="headerlink" title="1、买糖果"></a>1、买糖果</h4><h5 id="问题描述-6"><a href="#问题描述-6" class="headerlink" title="问题描述"></a>问题描述</h5><p>商店有 n 包糖，每包糖里面有 k 种口味，一共有 m（&lt;&#x3D;20）种口味，每包糖里面的口味用数字 1 到 20 表示，最少买几包糖可以吃遍所有口味</p>
<h5 id="代码逻辑-7"><a href="#代码逻辑-7" class="headerlink" title="代码逻辑"></a>代码逻辑</h5><ul>
<li>用二进制对口味编码，口味的数字为 i，那么二进制第 i-1 位就为 1，编码出来的一个二进制数就代表一种口味组合</li>
<li>资源从小遍历到大，如果某种口味组合可以被买到，那么它再加上当下的这包糖果的组合也可以被买到</li>
</ul>
<h5 id="核心代码-预处理"><a href="#核心代码-预处理" class="headerlink" title="核心代码_预处理"></a>核心代码_预处理</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求出每包糖果的口味组合</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=k;j++)</span><br><span class="line">       &#123;</span><br><span class="line">           cin&gt;&gt;taste;</span><br><span class="line">           pac[i] |= ( <span class="number">1</span>&lt;&lt; (taste<span class="number">-1</span>) );</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">max_taste = ( <span class="number">1</span>&lt;&lt;m ) - <span class="number">1</span>; <span class="comment">//从第0位到第m-1位都是1</span></span><br><span class="line"><span class="built_in">memset</span>(dp,inf,<span class="built_in">sizeof</span>(dp)); <span class="comment">//初始化所有口味组合都无法买到</span></span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">//口味组合：什么口味都不要，这种情况买0包就可以了</span></span><br></pre></td></tr></table></figure>

<h5 id="核心代码-状态转移"><a href="#核心代码-状态转移" class="headerlink" title="核心代码_状态转移"></a>核心代码_状态转移</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">   &#123;</span><br><span class="line">    	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=max_taste;j++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span>(dp[j]&lt;inf) <span class="comment">//可以买到口味组合j</span></span><br><span class="line">           &#123;</span><br><span class="line">           <span class="comment">//买到了口味组合j的基础上，买下当下这包糖果，可以让口味组合j|pac[i]所需的糖果更少，那么就更新答案</span></span><br><span class="line">               dp[ j | pac[i] ] = <span class="built_in">min</span>( dp[ j | pac[i] ], dp[j] + <span class="number">1</span> );</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.countingstars.cc/2024/09/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E8%B5%84%E6%BA%90%E4%BC%98%E5%8C%96%E7%89%88%EF%BC%89/" data-id="cm0mj3c8v00001cto3tpr99yh" data-title="动态规划（资源优化版）" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-图论" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/03/%E5%9B%BE%E8%AE%BA/" class="article-date">
  <time class="dt-published" datetime="2024-09-03T13:31:27.000Z" itemprop="datePublished">2024-09-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/03/%E5%9B%BE%E8%AE%BA/">图论</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="1、已知中、后序遍历求先序"><a href="#1、已知中、后序遍历求先序" class="headerlink" title="1、已知中、后序遍历求先序"></a>1、已知中、后序遍历求先序</h4><h5 id="代码逻辑"><a href="#代码逻辑" class="headerlink" title="代码逻辑"></a>代码逻辑</h5><ul>
<li>后序遍历的最后一个字符一定是当下二叉树的根结点，先序遍历中根节点首先被遍历，所以每找到一个根节点就输出。在中序遍历中，根结点前面的是左子树，后面的是右子树，根据后序遍历的最后一个字符可以确定根，从而根据中序遍历确定左子树，从而根据左子树的大小从后序遍历中取出左子树，然后递归求解子树，右子树同理用递归求解</li>
</ul>
<h5 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">forw</span><span class="params">(string s1, string s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!s<span class="number">1.</span><span class="built_in">size</span>()) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="type">char</span> root = s2[s<span class="number">2.</span><span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">	<span class="type">int</span> p = s<span class="number">1.f</span>ind(root);</span><br><span class="line">	std::cout&lt;&lt;root;</span><br><span class="line">	forw(s<span class="number">1.</span><span class="built_in">substr</span>(<span class="number">0</span>,p),s<span class="number">2.</span><span class="built_in">substr</span>(<span class="number">0</span>,p));</span><br><span class="line">	forw(s<span class="number">1.</span><span class="built_in">substr</span>(p<span class="number">+1</span>,std::string::npos),s<span class="number">2.</span><span class="built_in">substr</span>(p,s<span class="number">2.</span><span class="built_in">size</span>()-p<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、已知先、后序遍历，求中序"><a href="#2、已知先、后序遍历，求中序" class="headerlink" title="2、已知先、后序遍历，求中序"></a>2、已知先、后序遍历，求中序</h4><h5 id="代码逻辑-1"><a href="#代码逻辑-1" class="headerlink" title="代码逻辑"></a>代码逻辑</h5><ul>
<li>考虑一棵树只有一个根结点和一个结点，那么它子结点为左和子结点为右结点时，得出的先、后序遍历不变</li>
<li>如果树有一棵子树满足上述条件，那么子树有 2 种中序遍历，整棵树也就有 2 种中序遍历，根据乘法原理，如果树上有 k 个结点只有一个子结点，那么整棵树有 2^k^种中序遍历</li>
<li>如果一个结点只有一个子结点，那么先序遍历时，子结点一定在它的后一位，后序遍历时，子结点一定在它的前一位</li>
</ul>
<h5 id="核心代码-1"><a href="#核心代码-1" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pow = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=s<span class="number">1.l</span>ength()<span class="number">-2</span>;i++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=s<span class="number">2.l</span>ength()<span class="number">-1</span>;j++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span>( s1[i]==s2[j] &amp;&amp; s1[i<span class="number">+1</span>]==s2[j<span class="number">-1</span>] )</span><br><span class="line">               pow++;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">ans = (<span class="number">1</span>&lt;&lt;pow)</span><br></pre></td></tr></table></figure>

<h2 id="树的直径"><a href="#树的直径" class="headerlink" title="树的直径"></a>树的直径</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>边具有权重，如果以权重代表距离，那么整棵树距离最远的两个结点的距离就是树的直径</p>
<h3 id="代码逻辑-2"><a href="#代码逻辑-2" class="headerlink" title="代码逻辑"></a>代码逻辑</h3><ul>
<li>以任意结点（比如 1 结点）为起点，dfs 求出各结点到 1 结点的距离，找到距离 1 结点最远的 far 结点</li>
<li>以 far 结点为起点，dfs 求结点到 far 结点的距离，找到最大距离，最大距离就是树的直径</li>
</ul>
<h3 id="核心代码-2"><a href="#核心代码-2" class="headerlink" title="核心代码"></a>核心代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">( <span class="type">int</span> cur, <span class="type">int</span> fath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(dist[cur] &gt; D)</span><br><span class="line">	&#123;</span><br><span class="line">		D = dist[cur];</span><br><span class="line">		far = cur;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>( <span class="type">int</span> ver : edge[cur])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(ver==fat)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		dist[ver] = dist[cur] + <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(ver,cur);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><h4 id="1、城市规划"><a href="#1、城市规划" class="headerlink" title="1、城市规划"></a>1、城市规划</h4><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p>n 个城市有 n-1 条边，边权都视作 1，以 k 个城市组成核心城市，核心城市之间可以不经过普通城市相互联通，求其他城市到核心城市的最大距离的最小值</p>
<h5 id="代码逻辑-3"><a href="#代码逻辑-3" class="headerlink" title="代码逻辑"></a>代码逻辑</h5><ul>
<li>先求直径，dfs 找到以任意结点为起点，离它最远的结点 far，然后用 dfs 求离 far 最远的结点，第二份 dfs 相比前一份 dfs 多一行代码，每次递归求子结点 dfs 之前先令 fa[ver] &#x3D; cur，留下回溯数组方便找直径中点</li>
<li>直径中点作为核心城市的核心，其他所有结点都具有两个距离值，一个是自己到核心的距离，一个是自己联通的子结点距离核心最远的距离。为了让普通城市离核心城市群尽可能近，必须把自己到核心距离与子结点到核心最远距离的差值前 k-1 大的归为核心城市</li>
</ul>
<h5 id="核心代码-求直径留回溯"><a href="#核心代码-求直径留回溯" class="headerlink" title="核心代码_求直径留回溯"></a>核心代码_求直径留回溯</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">( <span class="type">int</span> cur, <span class="type">int</span> fat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(dist[cur] &gt; D)</span><br><span class="line">	&#123;</span><br><span class="line">		D = dist[cur];</span><br><span class="line">		far = cur;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> ver : edge[cur])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(ver==fat)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		dist[ver] = dist[cur] + <span class="number">1</span>;</span><br><span class="line">		fa[ver] = cur;</span><br><span class="line">		<span class="built_in">dfs</span>(ver,cur);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="核心代码-回溯找直径中点"><a href="#核心代码-回溯找直径中点" class="headerlink" title="核心代码_回溯找直径中点"></a>核心代码_回溯找直径中点</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">center = far;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=( D + <span class="number">1</span> )/<span class="number">2</span>;i++)</span><br><span class="line">	center = fa[center];</span><br></pre></td></tr></table></figure>

<h5 id="核心代码-核心距离、最深距离"><a href="#核心代码-核心距离、最深距离" class="headerlink" title="核心代码_核心距离、最深距离"></a>核心代码_核心距离、最深距离</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">( <span class="type">int</span> cur, <span class="type">int</span> fat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dist_max[cur] = dist[cur];</span><br><span class="line">	<span class="keyword">for</span>( <span class="type">int</span> ver : edge[cur])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(ver==fat)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		dist[ver] = dist[cur] + <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(ver,cur);</span><br><span class="line">		dist_max[cur] = dist_max[ver] &gt; dist_max[cur] ? dist_max[ver] : dist_max[cur];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h3 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h3><h4 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h4><p>N 个结点的图有 M 条无向有权边，判断能否生成一棵树，如果能则求出最小权重和</p>
<h4 id="代码逻辑-4"><a href="#代码逻辑-4" class="headerlink" title="代码逻辑"></a>代码逻辑</h4><ul>
<li>将边从小到大遍历，如果边的两个结点不在同一个并查集中，就合并它们，合并的权重代价就是这条边的权重</li>
</ul>
<h4 id="核心代码-3"><a href="#核心代码-3" class="headerlink" title="核心代码"></a>核心代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">       	<span class="type">int</span> root1 = <span class="built_in">FindRoot</span>(edge[i].u), root2 = <span class="built_in">FindRoot</span>(edge[i].v);</span><br><span class="line">        <span class="keyword">if</span>(root1==root2)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">		root[root1] = root[root2];</span><br><span class="line">        ans += edge[i].w;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">if</span>(cnt==n<span class="number">-1</span>)  <span class="comment">//合并n-1次并查集可以得到n个结点的树</span></span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Prime"><a href="#Prime" class="headerlink" title="Prime"></a>Prime</h3><h4 id="代码逻辑-5"><a href="#代码逻辑-5" class="headerlink" title="代码逻辑"></a>代码逻辑</h4><ul>
<li>起始让 1 结点入树，每当有结点入树就更新和它相连且未入树的结点到树的距离，每次找距离树最近的结点收入树中，无法用边联通的结点的距离视作 inf</li>
<li>visited 判断结点是否已经入树</li>
</ul>
<h4 id="核心代码-4"><a href="#核心代码-4" class="headerlink" title="核心代码"></a>核心代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">prime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">		dist[i] = inf;</span><br><span class="line">	<span class="keyword">for</span>(edge ver : e[<span class="number">1</span>])</span><br><span class="line">		dist[ver.to] = dist[ver.to] &lt; ver.weight ? dist[ver.to] : ver.weight;</span><br><span class="line">	<span class="type">int</span> now = <span class="number">1</span>, tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(++tot&lt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> min = inf;</span><br><span class="line">        visited[now] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i] &amp;&amp; min&gt;dist[i])</span><br><span class="line">            &#123;</span><br><span class="line">                min = dist[i];</span><br><span class="line">				now = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">   	<span class="comment">//树中结点还没到n个，但已经找不到可以连接的结点了</span></span><br><span class="line">        <span class="keyword">if</span>(min==inf)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ans+=min;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(edge ver : e[now])</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span>(!visited[ver.to] &amp;&amp; dist[ver.to]&gt;ver.weight)</span><br><span class="line">        		dist[ver.to] = ver.weight;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="树上结点最近祖先（LCA）"><a href="#树上结点最近祖先（LCA）" class="headerlink" title="树上结点最近祖先（LCA）"></a>树上结点最近祖先（LCA）</h2><h3 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h3><h4 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h4><p>n 个结点的树，s 为根，查询任意两个结点的最近祖先</p>
<h4 id="代码逻辑-6"><a href="#代码逻辑-6" class="headerlink" title="代码逻辑"></a>代码逻辑</h4><ul>
<li>先将两结点提到同一深度，然后一起向上回溯，回溯数组存 2 的幂次祖先，fa<del>now,i</del>表示从 now 向前回溯 2^i^得到的祖先</li>
<li>无论是提到同一高度还是一起回溯，都按照 2 的幂次为单位向前跳，可以降低时间开销</li>
<li>一起回溯时，从大到小遍历所有 2 的幂次级别的祖先结点，若不相同就跳。如果最近公共祖先是 x 结点，再向上看，两个结点上面的全部祖先结点肯定都相同</li>
</ul>
<h4 id="核心代码-预处理"><a href="#核心代码-预处理" class="headerlink" title="核心代码_预处理"></a>核心代码_预处理</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now, <span class="type">int</span> fath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//求深度</span></span><br><span class="line">	depth[now] = depth[fath] + <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//求回溯数组</span></span><br><span class="line">    fa[now][<span class="number">0</span>] = fath;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;= (<span class="type">int</span>)( <span class="built_in">log</span>(depth[now])/<span class="built_in">log</span>(<span class="number">2</span>) );i++)</span><br><span class="line">		fa[now][i] = fa[fa[now][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> ver : edge[now])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(ver!=fath)</span><br><span class="line">			<span class="built_in">dfs</span>(ver,now);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="核心代码-LCA-主程序"><a href="#核心代码-LCA-主程序" class="headerlink" title="核心代码_LCA 主程序"></a>核心代码_LCA 主程序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(depth[a]&lt;depth[b])</span><br><span class="line">		<span class="built_in">Swap</span>(a,b);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(depth[a]&gt;depth[b])</span><br><span class="line">		a = fa[a][log_2[depth[a]-depth[b]]<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">if</span>(a==b)</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=log_2[depth[a]]<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(fa[a][i]!=fa[b][i])</span><br><span class="line">			a = fa[a][i], b = fa[b][i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fa[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单源最短路径（Dijkstra）"><a href="#单源最短路径（Dijkstra）" class="headerlink" title="单源最短路径（Dijkstra）"></a>单源最短路径（Dijkstra）</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul>
<li><strong>Dijkstra</strong>只能处理无负权图的单源最短路径问题</li>
</ul>
<h3 id="例题-4"><a href="#例题-4" class="headerlink" title="例题"></a>例题</h3><h4 id="1、有向有权图单源最短距离"><a href="#1、有向有权图单源最短距离" class="headerlink" title="1、有向有权图单源最短距离"></a>1、有向有权图单源最短距离</h4><h5 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h5><p>n 个结点 m 条边，以 s 为源点，求其它所有结点到它的最短距离</p>
<h5 id="代码逻辑-7"><a href="#代码逻辑-7" class="headerlink" title="代码逻辑"></a>代码逻辑</h5><ul>
<li>辅助数据结构：优先队列 元素属性：队列中元素具有标号和距源点距离两个属性 排序方式：距离源点小的排前</li>
<li>先让源点入队，每次循环从队列中弹出元素，更新它子结点到源点的距离，将被修改的子结点入队</li>
<li>代码是广度优先搜索的逻辑，所以可能会出现同一个结点被修改多次，所以它会多次入队，由于是优先队列，只有第一次出队表示的才是它离源点的最短距离，所以用 visited 数组记录结点是否出过队</li>
</ul>
<h5 id="核心代码-5"><a href="#核心代码-5" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       q.<span class="built_in">push</span>( (node) &#123;s,<span class="number">0</span>&#125; );</span><br><span class="line">       <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="type">int</span> ind = q.<span class="built_in">top</span>().ind;</span><br><span class="line">           q.<span class="built_in">pop</span>();</span><br><span class="line">           <span class="keyword">if</span>(visited[ind])</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           <span class="keyword">for</span>( edge ver : e[ind] )</span><br><span class="line">           &#123;</span><br><span class="line">    			<span class="keyword">if</span>( dist[ver.to] &gt; dist[ind] + ver.w ) <span class="comment">//满足if条件的必然没有出过队</span></span><br><span class="line">               &#123;</span><br><span class="line">                   dist[ver.to] = dist[ind] + ver.w;</span><br><span class="line">                   q.<span class="built_in">push</span>( (node) &#123; ver.to,dist[ver.to] &#125; );</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、无向无权图单源最短路"><a href="#2、无向无权图单源最短路" class="headerlink" title="2、无向无权图单源最短路"></a>2、无向无权图单源最短路</h4><h5 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h5><p>n 个结点 m 条边的无向无权图（边权都视作 1）以 1 为源点，求抵达任意点的最短路径的条数</p>
<h5 id="代码逻辑-8"><a href="#代码逻辑-8" class="headerlink" title="代码逻辑"></a>代码逻辑</h5><ul>
<li>先初始化 dist<del>1</del>为 0，其它 dist 都为 inf，ans<del>1</del>为 1，其它 ans 为 0</li>
<li>利用优先队列，使到源点距离小的排前，但优先队列默认小的排后，所以传值时，传入距离的相反数</li>
<li>处理当下结点的子结点时，如果子结点 dist 大于当下结点 dist 再+1，那么说明从当下结点去到子结点才是去它的最短路径，赋值式更新子结的 ans，但如果子结点的 dist 原本就和当下结点的 dist 再+1 相等，由于每个结点只会 visit 一次，所以子结点的 dist 被另外一个父结点更新为了当下结点的 dist 再+1，由排列组合加法原理知子结点的 ans 应当加上当下结点的 ans</li>
</ul>
<h5 id="核心代码-6"><a href="#核心代码-6" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::priority_queue&lt; std::pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt; q;</span><br><span class="line">	q.<span class="built_in">push</span>( std::<span class="built_in">make_pair</span>(<span class="number">0</span>,<span class="number">1</span>) );</span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> pos = q.<span class="built_in">top</span>().second;</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span>(visited[pos])</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		visited[pos] = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> ver : edge[pos])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(dist[ver] &gt; dist[pos] + <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				dist[ver] = dist[pos] + <span class="number">1</span>;</span><br><span class="line">				ans[ver] = ans[pos];</span><br><span class="line">				q.<span class="built_in">push</span>( std::<span class="built_in">make_pair</span>(-dist[ver],ver) );</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(dist[ver] == dist[pos] + <span class="number">1</span>)</span><br><span class="line">				ans[ver] = ( ans[ver] + ans[pos] ) % mod;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="图上最小环"><a href="#图上最小环" class="headerlink" title="图上最小环"></a>图上最小环</h2><h3 id="例题-5"><a href="#例题-5" class="headerlink" title="例题"></a>例题</h3><h4 id="1、生日"><a href="#1、生日" class="headerlink" title="1、生日"></a>1、生日</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>现在有 n 个人，起始时每个人只知道自己的生日，每个人都有一个信息传递对象，这个传递对象可以是自己，每一轮都会把自己知道的所有生日告诉传递对象，最少多少轮的时候会有人从别人口中听到自己的生日？</p>
<h5 id="代码逻辑-9"><a href="#代码逻辑-9" class="headerlink" title="代码逻辑"></a>代码逻辑</h5><ul>
<li>这是一个找最小环的问题，因为每个人只有一个信息传递对象，所以环都是独立的</li>
<li>初始化每个人的传递对象为自己，每输入一个传递对象就判断能否构成环，可以的话就更新答案，不行的话说明更新传递对象</li>
<li>FindEnd 找到直线传递路径的终点，如果成环了，那么成环的结点的 nxt 不会被更新，所以它会导致 FindEnd 返回，也就是说，成环的结点就是直线传递路径的终点</li>
</ul>
<h5 id="核心代码-寻找直线传递路径终点"><a href="#核心代码-寻找直线传递路径终点" class="headerlink" title="核心代码_寻找直线传递路径终点"></a>核心代码_寻找直线传递路径终点</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">FindEnd</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       cnt++;  <span class="comment">//全局变量</span></span><br><span class="line">       <span class="keyword">if</span>(x==nxt[x])</span><br><span class="line">           <span class="keyword">return</span> x;</span><br><span class="line">      	<span class="keyword">return</span> <span class="built_in">FindEnd</span>(nxt[x]);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="核心代码-寻找最小环"><a href="#核心代码-寻找最小环" class="headerlink" title="核心代码_寻找最小环"></a>核心代码_寻找最小环</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">       nxt[i] = i;</span><br><span class="line">ans = inf;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="type">int</span> x;</span><br><span class="line">       cin&gt;&gt;x;</span><br><span class="line">       cnt = <span class="number">0</span>; <span class="comment">//全局变量</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="built_in">FindEnd</span>(x)==i)</span><br><span class="line">           ans = <span class="built_in">min</span>(ans,cnt);</span><br><span class="line">      	<span class="keyword">else</span></span><br><span class="line">           nxt[i] = x;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>拓扑结构关注结点之间的依赖关系</p>
<h3 id="例题-6"><a href="#例题-6" class="headerlink" title="例题"></a>例题</h3><h4 id="1、工序时间"><a href="#1、工序时间" class="headerlink" title="1、工序时间"></a>1、工序时间</h4><h5 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h5><p>有 n 项事件待做，输入 n 行，表示事件的标号和花费时间和需要的准备工作的标号，工人无限，可以无限制并行完成任务，输出完成所有事件的最小时间</p>
<h5 id="代码逻辑-10"><a href="#代码逻辑-10" class="headerlink" title="代码逻辑"></a>代码逻辑</h5><ul>
<li>利用入度数组 in 存下事件的前驱结点个数，如果入度为 0 了，就说明这件事情可以开始做了</li>
<li>ans 数组存完成各事件的最小时间，最终的答案为数组的最大值</li>
<li>入度为 0 的事件入队列，每次把出队列的对象的子结点的入度减 1，且更新它的 ans，同一个事件有多个前驱结点，ans 会被更新多次，必须取最大值，如果子结点的入度被减为 1，那么它入队列</li>
</ul>
<h5 id="核心代码-7"><a href="#核心代码-7" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span>(in[i])</span><br><span class="line">       &#123;</span><br><span class="line">           q.<span class="built_in">push</span>(i);</span><br><span class="line">           ans[i] = t[i];</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="type">int</span> temp = q.<span class="built_in">top</span>();</span><br><span class="line">       q.<span class="built_in">pop</span>();</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> ver : edge[temp])</span><br><span class="line">       &#123;</span><br><span class="line">		ans[ver] = <span class="built_in">max</span>( ans[ver], ans[temp] + t[ver] );</span><br><span class="line">           in[ver]--;</span><br><span class="line">           <span class="keyword">if</span>(in[ver]==<span class="number">0</span>)</span><br><span class="line">               q.<span class="built_in">push</span>(ver);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、火车站分级"><a href="#2、火车站分级" class="headerlink" title="2、火车站分级"></a>2、火车站分级</h4><h5 id="问题描述-5"><a href="#问题描述-5" class="headerlink" title="问题描述"></a>问题描述</h5><p>有 n 个站点（编号 1 到 n）的火车站，每个站点都有一个级别，火车站内走过了 m 躺火车，这些火车都遵循一个原则：如果在某一个站停了车，那么后面凡是级别大于等于这个站的站点都要停车，现在已知 m 躺火车停过的站，求火车站的站点至少有几种级别</p>
<h5 id="代码逻辑-11"><a href="#代码逻辑-11" class="headerlink" title="代码逻辑"></a>代码逻辑</h5><ul>
<li>这是一个用拓扑排序分层次的问题</li>
<li>火车停过的站之间没有停下的站的级别必然小于停过的站的级别，用 greater<del>i,j</del>表示 i 号站点级别是否大于 j 号站点，用 out 数组记录出度，out<del>i</del>存的是比 i 号站点级别小的站点的个数</li>
<li>每一层级可能有多个站点，但是答案只关注层级的个数，每次循环消去一个层级，把答案加 1</li>
</ul>
<h5 id="核心代码-8"><a href="#核心代码-8" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cnt,ans=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">	ans++;</span><br><span class="line">	<span class="comment">//删除最低层的站点，记下被删的站点</span></span><br><span class="line">	cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(out[i]==<span class="number">0</span> &amp;&amp; !deleted[i])</span><br><span class="line">		&#123;</span><br><span class="line">			lowest[++cnt] = i;</span><br><span class="line">			deleted[i] = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">       <span class="comment">//更新比被删除站点要高级的站点的出度</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(greater[j][lowest[i]])</span><br><span class="line">			&#123;</span><br><span class="line">				greater[j][lowest[i]] = <span class="literal">false</span>;</span><br><span class="line">				out[j]--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;<span class="keyword">while</span>(cnt); <span class="comment">//有执行删除操作才把答案加1，第一次进去的加1是多余的，所以ans初始化为-1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.countingstars.cc/2024/09/03/%E5%9B%BE%E8%AE%BA/" data-id="cm0mgxhd70000qytof7ia2noz" data-title="图论" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-动态规划（子问题最优解递推）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E5%AD%90%E9%97%AE%E9%A2%98%E6%9C%80%E4%BC%98%E8%A7%A3%E9%80%92%E6%8E%A8%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2024-09-03T13:29:48.000Z" itemprop="datePublished">2024-09-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E5%AD%90%E9%97%AE%E9%A2%98%E6%9C%80%E4%BC%98%E8%A7%A3%E9%80%92%E6%8E%A8%EF%BC%89/">动态规划（子问题最优解递推）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>问题可以划分为若干个子问题，从最小的子问题开始向上递推，最终解决总问题</li>
</ul>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="1、树形-dp（基础版）"><a href="#1、树形-dp（基础版）" class="headerlink" title="1、树形 dp（基础版）"></a>1、树形 dp（基础版）</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>n 个结点的无权无向图，结点存权重，有 n-1 条边，边相连结点不能同时选择，求最大权重和</p>
<h4 id="代码逻辑"><a href="#代码逻辑" class="headerlink" title="代码逻辑"></a>代码逻辑</h4><ul>
<li>边数比结点数少 1，构成树，无向图可以用任意结点作根结点</li>
<li>当下结点是否被选择这一信息必须保留，这是一个二维 dp 问题</li>
<li>dp<del>i0</del>表示以 i 为根且 i 不选的最优结果，dp<del>i1</del>表示以 i 为根且 i 选的最优结果，树划分为若干个子树</li>
<li>对每一个结点取它的最优解用来更新它父节点的结果，最终得到根结点的最优结果</li>
</ul>
<h4 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> cur,<span class="type">int</span> fath)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> ver : edge[cur])</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span>(ver==fath)</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           <span class="built_in">dfs</span>(ver,cur); <span class="comment">//从子问题得到总问题的解，先要解出子问题</span></span><br><span class="line">           dp[cur][<span class="number">0</span>] += <span class="built_in">max</span>(dp[ver][<span class="number">0</span>],dp[ver][<span class="number">1</span>]);</span><br><span class="line">           dp[cur][<span class="number">1</span>] += dp[ver][<span class="number">0</span>];</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、树形-dp（拓展版）"><a href="#2、树形-dp（拓展版）" class="headerlink" title="2、树形 dp（拓展版）"></a>2、树形 dp（拓展版）</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>n 个结点的无权有向图，结点存代价，边相连结点可以互相监视，求全部结点都被监视的最小代价</p>
<h4 id="代码逻辑-1"><a href="#代码逻辑-1" class="headerlink" title="代码逻辑"></a>代码逻辑</h4><ul>
<li>有向，所以要先找到总根，然后划分为子树，解决子问题再递推到总问题</li>
<li>二维 dp 问题，以 i 为根的子问题：如果 i 被选择，那么子结点选不选都可以让这棵树全部结点都被监视，如果 i 不被选择且要求这棵树不借助外来监视就可以被完全监视，那么子结点至少选一个，如果 i 不被选择且必须借助外来监视，那么子结点可以不选</li>
<li>0 表示选择根结点，1 表示不选择根节点但是整棵树被监视，2 表示不选择根结点，除了根节点之外整棵树被监视</li>
<li>根结点不选而且整棵树必须不借助外来监视就被完全监视，子树只能是 0 或者 1 状态，取最小值加到当下树即可，但是子树至少有一个是 0 状态，才能保证当下树是 0 状态，为了去掉子树的最小值都在 1 状态取的情况，求出每一个子树从最小值对应的状态到 0 状态的最小偏移量，当下树的结果加上这个偏移量</li>
<li>最后的答案从 dp<del>root,0</del>和 dp<del>root,1</del>中取一个最小值，不能取 dp~root,2</li>
</ul>
<h4 id="核心代码-1"><a href="#核心代码-1" class="headerlink" title="核心代码"></a>核心代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> cur)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> ver : edge[cur])</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">dfs</span>(ver);  <span class="comment">//从子问题得到总问题的解，先要解出子问题</span></span><br><span class="line">           <span class="comment">//cur被选，子结点任意</span></span><br><span class="line">           dp[cur][<span class="number">0</span>] += <span class="built_in">min</span>(dp[ver][<span class="number">0</span>],dp[ver][<span class="number">1</span>],dp[ver][<span class="number">2</span>]);</span><br><span class="line">           <span class="comment">//cur不选但整棵树被监视，子结点不允许借助外来监视</span></span><br><span class="line">           dp[cur][<span class="number">1</span>] += <span class="built_in">min</span>(dp[ver][<span class="number">0</span>],dp[ver][<span class="number">1</span>]);</span><br><span class="line">	<span class="comment">//对于状态1，对于每一个子结点都不要求必须选择，但是至少一个子结点需要被选择，下面排除一个子结点都不选的情况</span></span><br><span class="line">           dt = <span class="built_in">min</span>(dt,dp[ver][<span class="number">0</span>] - <span class="built_in">min</span>(dp[ver][<span class="number">0</span>],dp[ver][<span class="number">1</span>]) );</span><br><span class="line">           <span class="comment">//cur不选且必须借助外来监视，子结点不可选择，且子结点不可借助外来监视</span></span><br><span class="line">           dp[cur][<span class="number">2</span>] += dp[ver][<span class="number">1</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//如果最小偏移量为0，那么说明已经至少选择了一个子结点，那么dp[cur][1]需要加的量也就是0</span></span><br><span class="line">       dp[cur][<span class="number">1</span>] += dt;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、区间-dp"><a href="#3、区间-dp" class="headerlink" title="3、区间 dp"></a>3、区间 dp</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>n 块石头重量分别是 w<del>i</del>，合并两堆石头的代价是两堆石头的总重量和，只能合并相邻两堆石堆，求所有石头被合并为一堆石头最小代价</p>
<h4 id="代码逻辑-2"><a href="#代码逻辑-2" class="headerlink" title="代码逻辑"></a>代码逻辑</h4><ul>
<li>由于只能合并相邻两堆石堆，把问题划分为区间最值，dp<del>ij</del>表示 i 到 j 之间的石头被合成一堆的最小代价，i 到 j 之间的石头被分作两堆的方式很多，子问题划分的时候只有一件事是确定的，那就是子问题的石堆的长度小于总问题，比如 1-5 合并成 1 堆，可以先把 1-3 合并为 1 堆，4-5 合并成 1 堆，然后再把这两堆合并，也可以 1-2 合并，3-5 合并，然后这两堆合并，但是无论无何，总问题 1 堆长 5，子问题 1 堆的长度必然小于 5，根据堆的长度做递推。长度确定后，遍历起点 i，终点 j 就固定为 i+len-1，此时考虑 dp<del>ij</del>，它可以由很多种不同的方式转移过来，选一个结果最优的即可。</li>
</ul>
<h4 id="核心代码-预处理"><a href="#核心代码-预处理" class="headerlink" title="核心代码_预处理"></a>核心代码_预处理</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dp预处理</span></span><br><span class="line"><span class="built_in">memset</span>(dp,inf,<span class="built_in">sizeof</span>(dp))</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">       dp[i][i] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//前缀和预处理</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">   &#123;</span><br><span class="line">       cin&gt;&gt;w[i];</span><br><span class="line">       pre[i] = pre[i<span class="number">-1</span>] + w[i];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="核心代码-递推"><a href="#核心代码-递推" class="headerlink" title="核心代码_递推"></a>核心代码_递推</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">2</span>;len&lt;=n;len++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n-len<span class="number">+1</span>;i++)</span><br><span class="line">       &#123;</span><br><span class="line">           j = i + len - <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;j;k++)  <span class="comment">//遍历所有可能转移到当下结果的子结果，取最小的</span></span><br><span class="line">               dp[i][j] = <span class="built_in">min</span>(dp[i][j],dp[i][k]+dp[k<span class="number">+1</span>][j]+pre[j]-pre[i<span class="number">-1</span>] );</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.countingstars.cc/2024/09/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E5%AD%90%E9%97%AE%E9%A2%98%E6%9C%80%E4%BC%98%E8%A7%A3%E9%80%92%E6%8E%A8%EF%BC%89/" data-id="cm0mj1jnx0000azto4s6zgnul" data-title="动态规划（子问题最优解递推）" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-数据结构" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="article-date">
  <time class="dt-published" datetime="2024-09-03T13:29:10.000Z" itemprop="datePublished">2024-09-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>单调表示从起点开始单调，遇到破坏单调性的元素时，会去掉栈内的元素来保持单调。以单增栈为例，如果处理了原数组 1 到 n 号元素，那么栈内第一个元素必然是 1 到 n 之间最小的元素，第二个元素必然是 1 到 n 之间第二小的元素，但是无法保证栈的长度等于 n</p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="1、海报"><a href="#1、海报" class="headerlink" title="1、海报"></a>1、海报</h4><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p>N 个矩形房子拍成一排，高度分别是 h<del>i</del>用海报盖住它们，海报所盖之处不能是天空，最少用几张海报？</p>
<h5 id="代码逻辑"><a href="#代码逻辑" class="headerlink" title="代码逻辑"></a>代码逻辑</h5><ul>
<li>先假设答案为 N，如果两个房子同高，且它们之间的房子都比它们高，那么答案就可以减 1</li>
</ul>
<h5 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cin&gt;&gt;N&gt;&gt;h;</span><br><span class="line">s.<span class="built_in">push</span>(h);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=N;i++)</span><br><span class="line">   &#123;</span><br><span class="line">       cin&gt;&gt;h;</span><br><span class="line">       <span class="keyword">while</span>( !s.<span class="built_in">empty</span>() &amp;&amp; h &lt; s.<span class="built_in">top</span>() )</span><br><span class="line">           s.<span class="built_in">pop</span>();</span><br><span class="line">       <span class="keyword">if</span>( !s.<span class="built_in">empty</span>() &amp;&amp; s.<span class="built_in">top</span>()==h )</span><br><span class="line">           ans--;</span><br><span class="line">      	s.<span class="built_in">push</span>(h);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>单调表示从起点开始单调，遇到破坏单调性的元素时，会去掉队列内的元素来保持单调。以单增队列为例，如果处理了原数组 1 到 n 号元素，那么队列内第一个元素必然是 1 到 n 之间最小的元素，第二个元素必然是 1 到 n 之间第二小的元素，但是无法保证队列的长度等于 n</p>
<h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><h4 id="1、k-区间最大极值差"><a href="#1、k-区间最大极值差" class="headerlink" title="1、k 区间最大极值差"></a>1、k 区间最大极值差</h4><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>有 N 个数字，F<del>i</del>表示区间[max(1,i-k),i]之间的最大值与最小值的差，求 F<del>i</del>的最大值</p>
<h5 id="代码逻辑-1"><a href="#代码逻辑-1" class="headerlink" title="代码逻辑"></a>代码逻辑</h5><ul>
<li>维护一个单增队列和一个单减队列求极值差</li>
<li>由于 1-2、1-3….1-k 的最大极值差必然是 1-k 的极值差，求出原数组 1-k 之间的极值差，以代表 i&lt;&#x3D;k 时的答案</li>
<li>i&gt;k 时，每次将 k 区间右移一位，最左边的元素被移出，在队列中删去它</li>
</ul>
<h5 id="核心代码-1"><a href="#核心代码-1" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;deque&gt;</span></span></span><br><span class="line">........</span><br><span class="line">    <span class="comment">//先处理1-k区间的极值差</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>( !dq<span class="number">1.</span><span class="built_in">empty</span>() &amp;&amp; data[i]&lt;dq<span class="number">1.</span><span class="built_in">back</span>() )</span><br><span class="line">            dq<span class="number">1.</span><span class="built_in">pop_back</span>();</span><br><span class="line">        dq<span class="number">1.</span><span class="built_in">push_back</span>(data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>( !dq<span class="number">2.</span><span class="built_in">empty</span>() &amp;&amp; data[i]&gt;dq<span class="number">2.</span><span class="built_in">back</span>() )</span><br><span class="line">            dq<span class="number">2.</span><span class="built_in">pop_back</span>();</span><br><span class="line">       	dq<span class="number">2.</span><span class="built_in">push_back</span>(data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">	ans = dq<span class="number">2.f</span>ront() - dq<span class="number">1.f</span>ront();</span><br><span class="line">	<span class="comment">//处理后面的k区间</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=k<span class="number">+1</span>;i&lt;=n-k<span class="number">+1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">     	<span class="keyword">while</span>( !dq<span class="number">1.</span><span class="built_in">empty</span>() &amp;&amp; data[i]&lt;dq<span class="number">1.</span><span class="built_in">back</span>() )</span><br><span class="line">            dq<span class="number">1.</span><span class="built_in">pop_back</span>();</span><br><span class="line">       	dq<span class="number">1.</span><span class="built_in">push_back</span>(data[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( !dq<span class="number">2.</span><span class="built_in">empty</span>() &amp;&amp; data[i]&gt;dq<span class="number">2.</span><span class="built_in">back</span>() )</span><br><span class="line">            dq<span class="number">2.</span><span class="built_in">pop_back</span>();</span><br><span class="line">       	dq<span class="number">2.</span><span class="built_in">push_bac</span>(data[i]);</span><br><span class="line">        <span class="comment">//处理被移出去的元素</span></span><br><span class="line">        <span class="keyword">if</span>(dq<span class="number">1.f</span>ront()==data[i-k])</span><br><span class="line">            dq<span class="number">1.</span><span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">if</span>(dq<span class="number">2.f</span>ront()==data[i-k])</span><br><span class="line">            dq<span class="number">2.</span><span class="built_in">pop_front</span>();</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,dq<span class="number">2.f</span>ront()-dq<span class="number">1.f</span>ront());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li><p>c++的 map 库中提供了数据类型 map，实现键值对的映射</p>
</li>
<li><p>map 会自动按照 first 第一，second 其次的优先级来排序</p>
</li>
</ul>
<h3 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h3><h4 id="1、点赞日志"><a href="#1、点赞日志" class="headerlink" title="1、点赞日志"></a>1、点赞日志</h4><h5 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h5><p>有 N 条点赞记录，每条记录包含被点赞内容的编号 id 和点赞时间 ts，如果存在 T，使得[T,T+D)之间 id 被赞的次数大于 k，那么就输出 id</p>
<h5 id="代码逻辑-2"><a href="#代码逻辑-2" class="headerlink" title="代码逻辑"></a>代码逻辑</h5><ul>
<li>用键值对&lt; id,vector&lt;int&gt; &gt;记录数据即可</li>
</ul>
<h5 id="核心代码-2"><a href="#核心代码-2" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">map&lt; string, vector&lt;<span class="type">int</span>&gt; &gt; mp;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">   &#123;</span><br><span class="line">       cin&gt;&gt;id&gt;&gt;ts;</span><br><span class="line">       mp[id].<span class="built_in">push</span>(ts);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> ver : mp)</span><br><span class="line">   &#123;</span><br><span class="line">    	vector&lt;<span class="type">int</span>&gt; temp = mp.second;</span><br><span class="line">       <span class="keyword">if</span>(temp.<span class="built_in">size</span>()&lt;k)</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">       <span class="built_in">sort</span>(temp.<span class="built_in">begin</span>(),temp.<span class="built_in">end</span>());</span><br><span class="line">       <span class="comment">//枚举点赞记录时间起点，如果可以找到大于等于k条满足条件的点赞记录，就输出id</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=temp.<span class="built_in">size</span>()-k<span class="number">+1</span>;i++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;=i+k;j++)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">if</span>(temp[j]-temp[i]&lt;D)</span><br><span class="line">                   ans++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(ans&gt;=k)</span><br><span class="line">           &#123;</span><br><span class="line">               cout&lt;&lt;ver.first&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>将祖先结点相同的结点放入同一个集合</p>
<h3 id="路径压缩算法"><a href="#路径压缩算法" class="headerlink" title="路径压缩算法"></a>路径压缩算法</h3><ul>
<li>如果每次找结点的祖先结点都一个个父节点向上回溯，就多做了很多次不必要的操作</li>
<li>路径压缩算法每回溯一次都把结点的父结点赋值为父结点的父结点，这样下次调用的时候就不用再做已经做过的回溯</li>
</ul>
<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">FindRoot</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> root[index]==index ? index : ( root[index] = <span class="built_in">FindRoot</span>(root[index]) );</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h3><h4 id="1、奶酪"><a href="#1、奶酪" class="headerlink" title="1、奶酪"></a>1、奶酪</h4><h5 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h5><p>奶酪高度 h，有 n 个半径 r 的洞(坐标 x<del>i</del>,y<del>i</del>)，上表面视作高度 h，下表面视作高度 0，是否存在一条路径贯穿上下表面</p>
<h5 id="代码逻辑-3"><a href="#代码逻辑-3" class="headerlink" title="代码逻辑"></a>代码逻辑</h5><ul>
<li>枚举与上下表面联通的洞，如果能找到一对洞分别与上表面和下表面联通且它们有公共祖先结点，那么输出”YES”，否则输出”NO”</li>
</ul>
<h5 id="核心代码-3"><a href="#核心代码-3" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">   &#123;</span><br><span class="line">   	cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">       <span class="keyword">if</span>(<span class="built_in">is_up</span>())</span><br><span class="line">        	up.<span class="built_in">push_back</span>(x,y);</span><br><span class="line">      	<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">is_down</span>())</span><br><span class="line">           down.<span class="built_in">push_back</span>(x,y);</span><br><span class="line">       all[i] = &#123;x,y&#125;;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span>(<span class="built_in">connected</span>())</span><br><span class="line">           &#123;</span><br><span class="line">               root1 = <span class="built_in">FindRoot</span>(i), root2 = <span class="built_in">FindRoot</span>(j);</span><br><span class="line">               <span class="keyword">if</span>(root1!=root2)</span><br><span class="line">            <span class="comment">//直接修改祖先结点的祖先结点，表示两个并查集的合并</span></span><br><span class="line">                   root[root1] = root[root2];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、关押犯人"><a href="#2、关押犯人" class="headerlink" title="2、关押犯人"></a>2、关押犯人</h4><h5 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h5><p>两个监狱关押 N 个犯人，有 M 对仇恨值，仇恨对象在同一监狱就会爆发等同于仇恨值的冲突，合理放置犯人使最大的冲突值最小</p>
<h5 id="代码逻辑-4"><a href="#代码逻辑-4" class="headerlink" title="代码逻辑"></a>代码逻辑</h5><ul>
<li>仇恨值从大到小排列，优先规避大仇恨值，第一个无法规避的仇恨值就是实际爆发的冲突中的最大值，由于可能的更大值已经被规避，所以实际的最大冲突值就是最大冲突值的最小值</li>
<li>规避仇恨的方法就是把仇恨的对象的所有敌人都放入同一个监狱，也就是同一个集合</li>
</ul>
<h5 id="核心代码-4"><a href="#核心代码-4" class="headerlink" title="核心代码"></a>核心代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//表示仇恨对象和仇恨值</span></span><br><span class="line">    <span class="type">int</span> x,y,c;</span><br><span class="line">&#125;data[maxn];</span><br><span class="line"><span class="type">int</span> enemy[maxn]; <span class="comment">//表示犯人的第一个仇人</span></span><br><span class="line">..................</span><br><span class="line">    <span class="built_in">sort</span>(data,data+m,[](node n1,node n2)&#123;<span class="keyword">return</span> n<span class="number">1.</span>c &gt; n<span class="number">2.</span>c;&#125;);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">FindRoot</span>(data[i].x) == <span class="built_in">FindRoot</span>(data[i].y) ) <span class="comment">//找到第一对无法避免的冲突</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;data[i].c;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(enemy[data[i].x]==<span class="number">0</span>) <span class="comment">//输入第一个敌人</span></span><br><span class="line">            enemy[data[i].x] = data[i].y;</span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">//已经有第一个敌人</span></span><br><span class="line">            root[<span class="built_in">FindRoot</span>(enemy[data[i].x])] = root[<span class="built_in">FindRoot</span>(data[i].y)];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(enemy[data[i].y]==<span class="number">0</span>)</span><br><span class="line">            enemy[data[i].y] = data[i].x;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            root[<span class="built_in">FindRoot</span>(enemy[data[i].y])] = root[<span class="built_in">FindRoot</span>(data[i].x)];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="ST-表"><a href="#ST-表" class="headerlink" title="ST 表"></a>ST 表</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p><strong>ST 表</strong>可以实现离线查询区间最值的功能</p>
<h3 id="代码逻辑-5"><a href="#代码逻辑-5" class="headerlink" title="代码逻辑"></a>代码逻辑</h3><ul>
<li><strong>ST 表</strong>把区间划分为长度为 2 的幂次的子区间，st<del>ij</del>表示原数组从 i 到 i+$$2^j-1$$的最值</li>
<li>求任意区间最值时，只需把区间划分为两个长度为 2 的幂次的子区间，查 st 表得最值</li>
<li>任意区间划分原则：长度对半分，断点 k&#x3D;$$log_2{(R-L+1)}$$</li>
</ul>
<h3 id="核心代码-生成-ST-表"><a href="#核心代码-生成-ST-表" class="headerlink" title="核心代码_生成 ST 表"></a>核心代码_生成 ST 表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=maxj;j++)  <span class="comment">//区间长度为2^j,区间长度大的st值由更小的区间得到</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)  <span class="comment">//区间起点为i，起点小的st值需要依赖起点大的st值获得</span></span><br><span class="line">           st[i][j] = <span class="built_in">max</span>( st[i][j<span class="number">-1</span>], st[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>] );</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="核心代码-任意区间查值"><a href="#核心代码-任意区间查值" class="headerlink" title="核心代码_任意区间查值"></a>核心代码_任意区间查值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> L,<span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="type">int</span> k = <span class="built_in">log</span>(R-L<span class="number">+1</span>) / <span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line">       <span class="comment">//确保区间被划分为两个长为2^k的区间，所以后一个区间的左端点不是L+(1&lt;&lt;k)</span></span><br><span class="line">       <span class="comment">//又为了确保后一个区间的左端点小于等于前一个区间的右端点，计算求得k的值log(R-L+1) / log(2)</span></span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">max</span>(st[L][k],st[R-(<span class="number">1</span>&lt;&lt;k)<span class="number">+1</span>][k]);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><ul>
<li>树状数组是对原数组更快速的管理方式，普通树状数组可用于单点修改和区间查询，如果引入差分数组就可以实现区间修改、单点查询、区间和查询，这里所有的修改和查询都指对原数组的操作。</li>
<li>普通树状数组是管理原数组的工具</li>
<li>差分树状数组是管理差分数组从而管理原数组的工具</li>
<li>树状数组大小和原数组一样</li>
</ul>
<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><ul>
<li><p><strong>lowbit(x)：</strong>x 二进制表示中最低位 1 代表的数字，lowbit(x) &#x3D; x&amp;(~x+1)</p>
</li>
<li><p><strong>差分数组：</strong>差分数组 data_diff<del>i</del> &#x3D; data<del>i</del>-data<del>i-1</del></p>
</li>
</ul>
<h3 id="代码逻辑-6"><a href="#代码逻辑-6" class="headerlink" title="代码逻辑"></a>代码逻辑</h3><ul>
<li>树状数组中下标为 x 的节点的父节点为下标为 x+lowbit(x)的节点</li>
<li>每一个节点存的数据是本身数据以及本身的子节点数据的和</li>
<li>求原数组下标 1-x 的和是从树状数组下标为 x 的节点开始加，每次下标减去 lowbit(x)</li>
</ul>
<h3 id="核心代码-创建树状数组-单点修改"><a href="#核心代码-创建树状数组-单点修改" class="headerlink" title="核心代码_创建树状数组&#x2F;单点修改"></a>核心代码_创建树状数组&#x2F;单点修改</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建树状数组的过程相当于做单点修改,原数组下标为i的值从0修改为输入的data[i]</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> index,<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=index;i&lt;=n;i+=<span class="built_in">lowbit</span>(i)) <span class="comment">//回溯每一个父节点</span></span><br><span class="line">			data_tree[i] += value;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="核心代码-区间和查询"><a href="#核心代码-区间和查询" class="headerlink" title="核心代码_区间和查询"></a>核心代码_区间和查询</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> L,<span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">     	<span class="keyword">for</span>(<span class="type">int</span> i=R;i&gt;=<span class="number">1</span>;i-=<span class="built_in">lowbit</span>(i))</span><br><span class="line">           ans += data_tree[i];</span><br><span class="line">       <span class="keyword">if</span>(L==<span class="number">1</span>)</span><br><span class="line">           <span class="keyword">return</span> ans;</span><br><span class="line">      	<span class="keyword">for</span>(<span class="type">int</span> i=L<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i-=<span class="built_in">lowbit</span>(i))</span><br><span class="line">           ans -= data_tree[i];</span><br><span class="line">      	<span class="keyword">return</span> ans;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="核心代码-差分数组创建树状数组-单点修改"><a href="#核心代码-差分数组创建树状数组-单点修改" class="headerlink" title="核心代码_差分数组创建树状数组&#x2F;单点修改"></a>核心代码_差分数组创建树状数组&#x2F;单点修改</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建树状数组的过程相当于做单点修改,原数组下标为i的值从0修改为输入的data[i]</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;data[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j+=<span class="built_in">lowbit</span>(j))</span><br><span class="line">            data_tree[j] = data[i] - data[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="核心代码-差分树状数组单点查询"><a href="#核心代码-差分树状数组单点查询" class="headerlink" title="核心代码_差分树状数组单点查询"></a>核心代码_差分树状数组单点查询</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询的是差分数组的1-index的和，也就是原数组的单点值</span></span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">      	<span class="keyword">for</span>(<span class="type">int</span> i=index;i&gt;=<span class="number">1</span>;i-=<span class="built_in">lowbit</span>(i))</span><br><span class="line">            ans += data_tree[i];</span><br><span class="line">       	<span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="核心代码-差分树状数组区间修改"><a href="#核心代码-差分树状数组区间修改" class="headerlink" title="核心代码_差分树状数组区间修改"></a>核心代码_差分树状数组区间修改</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原数组在区间改值，相当于差分数组在left处+k，在right+1处-k，反映到树状数组就是做两次单点修改</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=left;i&lt;=n;i+=<span class="built_in">lowbit</span>(i))</span><br><span class="line">            data_tree[i] += k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=right<span class="number">+1</span>;i&lt;=n;i+=<span class="built_in">lowbit</span>(i))</span><br><span class="line">            data_tree[i] = -k;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="求和线段树"><a href="#求和线段树" class="headerlink" title="求和线段树"></a>求和线段树</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p><strong>求和线段树</strong>可完成区间修改（加法和乘法）和区间和查询的功能，需要的空间是原数组的 4 倍</p>
<h3 id="代码逻辑-7"><a href="#代码逻辑-7" class="headerlink" title="代码逻辑"></a>代码逻辑</h3><ul>
<li>pos 表示树上结点，low-hight 表示 pos 结点树控制的原数组的位置</li>
<li>利用 tag 数组延迟完成改值操作，减少修改操作的次数，tag 的值只有 pos 的子结点才会用到</li>
<li>x、y、k 是输入的参数，分别表示操作的区间[x,y]以及操作数 k</li>
<li>每次调用 add 或者 mul 时，最终终止的地方，其父结点全都会被及时处理，其子结点会延迟处理，而每一次调用 add、mul、query 都是从 pos&#x3D;1 开始的，所以 tree[1]的值总是正确的。如果一进 query 就返回了，那么输出的结果是 tree[pos]，不然就会先 pushdown 把子结点的值修改正确再调用 query 查询子结点，因此查询值总是正确的。</li>
</ul>
<h3 id="核心代码-建树"><a href="#核心代码-建树" class="headerlink" title="核心代码_建树"></a>核心代码_建树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> low , <span class="type">int</span> hight)</span>  <span class="comment">//递归建树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(low == hight)</span><br><span class="line">	&#123;</span><br><span class="line">		tree[pos] = data[low];</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid = low + ( (hight - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">build</span>(pos&lt;&lt;<span class="number">1</span>, low, mid);</span><br><span class="line">	<span class="built_in">build</span>( (pos&lt;&lt;<span class="number">1</span>)<span class="number">+1</span>, mid<span class="number">+1</span>, hight);</span><br><span class="line">	tree[pos] = tree[pos&lt;&lt;<span class="number">1</span>] + tree[(pos&lt;&lt;<span class="number">1</span>)<span class="number">+1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="核心代码-向下传标记（tag）"><a href="#核心代码-向下传标记（tag）" class="headerlink" title="核心代码_向下传标记（tag）"></a>核心代码_向下传标记（tag）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> low, <span class="type">int</span> hight)</span>  <span class="comment">//向下改值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> mid = low + ( ( hight - low) &gt;&gt; <span class="number">1</span> );</span><br><span class="line">	<span class="comment">//修改子结点的值,乘法优先</span></span><br><span class="line">	tree[pos&lt;&lt;<span class="number">1</span>] =  tree[pos&lt;&lt;<span class="number">1</span>] * tag_mul[pos]  + ( mid - low + <span class="number">1</span> ) * tag_add[pos];</span><br><span class="line">	tree[(pos&lt;&lt;<span class="number">1</span>)<span class="number">+1</span>] =  tree[(pos&lt;&lt;<span class="number">1</span>)<span class="number">+1</span>] * tag_mul[pos] + ( hight - mid ) * tag_add[pos];</span><br><span class="line">	<span class="comment">//修改子结点的tag,乘法优先</span></span><br><span class="line">	tag_mul[pos&lt;&lt;<span class="number">1</span>] = tag_mul[pos&lt;&lt;<span class="number">1</span>] * tag_mul[pos];</span><br><span class="line">	tag_mul[(pos&lt;&lt;<span class="number">1</span>)<span class="number">+1</span>] = tag_mul[(pos&lt;&lt;<span class="number">1</span>)<span class="number">+1</span>] * tag_mul[pos];</span><br><span class="line">	tag_add[pos&lt;&lt;<span class="number">1</span>] = tag_add[pos&lt;&lt;<span class="number">1</span>] * tag_mul[pos] + tag_add[pos];</span><br><span class="line">	tag_add[(pos&lt;&lt;<span class="number">1</span>)<span class="number">+1</span>] = tag_add[(pos&lt;&lt;<span class="number">1</span>)<span class="number">+1</span>] * tag_mul[pos] + tag_add[pos];</span><br><span class="line">	<span class="comment">//复原当下结点的tag</span></span><br><span class="line">	tag_mul[pos] = <span class="number">1</span>;</span><br><span class="line">	tag_add[pos] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="核心代码-区间改值（加法）"><a href="#核心代码-区间改值（加法）" class="headerlink" title="核心代码_区间改值（加法）"></a>核心代码_区间改值（加法）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> low, <span class="type">int</span> hight)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=low &amp;&amp; y&gt;=hight) <span class="comment">//这个结点控制的区间已经被完全覆盖</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//修改当下位置树的值并设置tag</span></span><br><span class="line">		tree[pos] = tree[pos] +  ( hight - low + <span class="number">1</span>) * k;</span><br><span class="line">		tag_add[pos] = tag_add[pos] + k;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">pushdown</span>(pos, low, hight); <span class="comment">//递归结束后做回溯的时候及时传递tag标记</span></span><br><span class="line">	<span class="type">int</span> mid = low +  ( ( hight - low ) &gt;&gt; <span class="number">1</span> );</span><br><span class="line">	<span class="comment">//如果左右子结点控制的区间有被影响到，那么就对它们调用add函数</span></span><br><span class="line">	<span class="keyword">if</span>(x&lt;=mid)</span><br><span class="line">		<span class="built_in">add</span>(pos&lt;&lt;<span class="number">1</span>, low, mid);</span><br><span class="line">	<span class="keyword">if</span>(y&gt;=mid<span class="number">+1</span>)</span><br><span class="line">		<span class="built_in">add</span>( (pos&lt;&lt;<span class="number">1</span>)<span class="number">+1</span>, mid<span class="number">+1</span>, hight);</span><br><span class="line">	<span class="comment">//改完左右结点后，给当下结点重新赋值</span></span><br><span class="line">	tree[pos] = tree[pos&lt;&lt;<span class="number">1</span>] + tree[(pos&lt;&lt;<span class="number">1</span>)<span class="number">+1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="核心代码-区间改值（乘法）"><a href="#核心代码-区间改值（乘法）" class="headerlink" title="核心代码_区间改值（乘法）"></a>核心代码_区间改值（乘法）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> low, <span class="type">int</span> hight)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=low &amp;&amp; y&gt;=hight)</span><br><span class="line">	&#123;</span><br><span class="line">		tree[pos] = tree[pos] * k;</span><br><span class="line">		tag_mul[pos] = tag_mul[pos] * k;</span><br><span class="line">		tag_add[pos] = tag_add[pos] * k; <span class="comment">//注意：做乘法操作的时候会影响前面遗留的加法</span></span><br><span class="line">		<span class="keyword">return</span>	;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">pushdown</span>(pos, low, hight);</span><br><span class="line">	<span class="type">int</span> mid = low + ( ( hight - low ) &gt;&gt; <span class="number">1</span> );</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=mid)</span><br><span class="line">		<span class="built_in">mul</span>( pos&lt;&lt;<span class="number">1</span>, low, mid);</span><br><span class="line">	<span class="keyword">if</span>(y&gt;=mid<span class="number">+1</span>)</span><br><span class="line">		<span class="built_in">mul</span>( (pos&lt;&lt;<span class="number">1</span>)<span class="number">+1</span>, mid<span class="number">+1</span>, hight);</span><br><span class="line">	tree[pos] = tree[pos&lt;&lt;<span class="number">1</span>] + tree[(pos&lt;&lt;<span class="number">1</span>)<span class="number">+1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="核心代码-区间和查询-1"><a href="#核心代码-区间和查询-1" class="headerlink" title="核心代码_区间和查询"></a>核心代码_区间和查询</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> low, <span class="type">int</span> hight)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=low &amp;&amp; y&gt;=hight)</span><br><span class="line">		<span class="keyword">return</span> tree[pos];</span><br><span class="line">	<span class="built_in">pushdown</span>(pos,low,hight);</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>, mid = low + ( ( hight - low ) &gt;&gt; <span class="number">1</span> );</span><br><span class="line">	<span class="keyword">if</span>(x&lt;=mid)</span><br><span class="line">		ans += <span class="built_in">query</span>(pos&lt;&lt;<span class="number">1</span>, low, mid);</span><br><span class="line">	<span class="keyword">if</span>(y&gt;=mid<span class="number">+1</span>)</span><br><span class="line">		ans += <span class="built_in">query</span>( (pos&lt;&lt;<span class="number">1</span>)<span class="number">+1</span>, mid<span class="number">+1</span>, hight );</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><p><strong>字典树</strong>对前缀进行复用，查找时可以省时间</p>
<h3 id="代码逻辑-8"><a href="#代码逻辑-8" class="headerlink" title="代码逻辑"></a>代码逻辑</h3><ul>
<li>二维数组存三个信息，第一维存起始结点，数据存终止结点，第二维存这两个结点之间的值</li>
</ul>
<h3 id="例题-4"><a href="#例题-4" class="headerlink" title="例题"></a>例题</h3><h4 id="1、字符串前缀"><a href="#1、字符串前缀" class="headerlink" title="1、字符串前缀"></a>1、字符串前缀</h4><h5 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h5><p>有 n 个文本串和 m 个模式串，求出各匹配串在文本串的前缀中出现的次数</p>
<h5 id="核心代码-插入字符串"><a href="#核心代码-插入字符串" class="headerlink" title="核心代码_插入字符串"></a>核心代码_插入字符串</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="type">int</span> x = <span class="number">1</span>;  <span class="comment">//从字典树起点开始</span></span><br><span class="line">      	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span>(!trie[x][s[i]-<span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">               trie[x][s[i]-<span class="string">&#x27;a&#x27;</span>] = ind++; <span class="comment">//字典树数组的栈顶指针</span></span><br><span class="line">           x = trie[x][s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="核心代码-查询字符串"><a href="#核心代码-查询字符串" class="headerlink" title="核心代码_查询字符串"></a>核心代码_查询字符串</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)</span><br><span class="line">       &#123;</span><br><span class="line">           x = trie[x][s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">           <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="comment">//匹配到某个字符时，字典树中无对应的边，说明失配</span></span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> x;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、异或最大值"><a href="#2、异或最大值" class="headerlink" title="2、异或最大值"></a>2、异或最大值</h4><h5 id="问题描述-5"><a href="#问题描述-5" class="headerlink" title="问题描述"></a>问题描述</h5><p>有 n 个数字，可以任意两两组合做异或，求出可得的最大值</p>
<h5 id="代码逻辑-9"><a href="#代码逻辑-9" class="headerlink" title="代码逻辑"></a>代码逻辑</h5><ul>
<li>对每个数字，找到和它和其他数字异或的最大结果，再利用各自的最大值求得总最大值即可</li>
<li>字典树寻找异或结果最大值：利用二进制编码构造 01 字典树，利用贪心思想，每一步都选择和自己对应数位相反的结点</li>
<li>字典树建立：为了统一，所有 int 数都看成 31 位二进制，只忽略了符号位的 0</li>
</ul>
<h5 id="核心代码-建树-1"><a href="#核心代码-建树-1" class="headerlink" title="核心代码_建树"></a>核心代码_建树</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> data)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">30</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">       &#123;</span><br><span class="line">    		<span class="keyword">if</span>(!trie[x][ (data&gt;&gt;j)&amp;<span class="number">1</span> ])</span><br><span class="line">               trie[x][ (data&gt;&gt;j)&amp;<span class="number">1</span> ] = ind++; <span class="comment">//字典树数组的栈顶指针</span></span><br><span class="line">          	x = trie[x][ (data&gt;&gt;j)&amp;<span class="number">1</span> ]</span><br><span class="line">       &#125;</span><br><span class="line">       val[x] = data;  <span class="comment">//十进制值与字典树终点建立映射关系，方便查询</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="核心代码-寻找异或最大值"><a href="#核心代码-寻找异或最大值" class="headerlink" title="核心代码_寻找异或最大值"></a>核心代码_寻找异或最大值</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxEXOR</span><span class="params">(<span class="type">int</span> data)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">30</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">//优先选择和自己对应数位数字不同的路径</span></span><br><span class="line">           <span class="keyword">if</span>(trie[x][ !( (data&gt;&gt;j)&amp;<span class="number">1</span> ) ])</span><br><span class="line">               x = trie[x][ !( (data&gt;&gt;j)&amp;<span class="number">1</span> ) ];</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               x = trie[x][ (data&gt;&gt;j)&amp;<span class="number">1</span> ];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> data ^ val[x];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.countingstars.cc/2024/09/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" data-id="cm0mgvkgh0002j9to9g77fvrd" data-title="数据结构" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Manacher算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/03/Manacher%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2024-09-03T13:27:49.000Z" itemprop="datePublished">2024-09-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/03/Manacher%E7%AE%97%E6%B3%95/">Manacher算法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>利用 O(N)的复杂度求出字符串的最大回文半径</p>
<h4 id="前置知识与预处理"><a href="#前置知识与预处理" class="headerlink" title="前置知识与预处理"></a>前置知识与预处理</h4><h5 id="回文中心"><a href="#回文中心" class="headerlink" title="回文中心"></a>回文中心</h5><p>对于长度为奇数的回文串而言，其具有回文中心，但如果回文串的长度为偶数，那么其无回文中心。<br>为了处理方便处理，先将字符串拓展成 2<em>length+3 的长度，在首尾补上两个特殊字符当作终止符，编号 1 至 2</em>length+1 之间奇数编号赋值#，偶数编号从小到大依次赋值为原字符串的字符</p>
<h6 id="图例"><a href="#图例" class="headerlink" title="图例"></a>图例</h6><table>
<thead>
<tr>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">C</th>
<th align="center">C</th>
<th align="center">C</th>
<th align="center">B</th>
<th align="center">A</th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">^</td>
<td align="center">#</td>
<td align="center">A</td>
<td align="center">#</td>
<td align="center">B</td>
<td align="center">#</td>
<td align="center">C</td>
<td align="center">#</td>
<td align="center">C</td>
<td align="center">#</td>
<td align="center">B</td>
<td align="center">#</td>
<td align="center">A</td>
<td align="center">#</td>
<td align="center">$</td>
</tr>
</tbody></table>
<p>显然，处理后的字符串最大回文半径比原字符串大 1</p>
<h4 id="代码逻辑"><a href="#代码逻辑" class="headerlink" title="代码逻辑"></a>代码逻辑</h4><p>如果两个元素处于一个回文区间的对称位置，那么可以用前面的元素的最大回文半径给后面元素的最大回文半径赋值，但是赋值时不能让后面元素的最大回文区间右端点超出当下回文区间的右端点，因为可赋值的性质是在当下回文区间之中的性质，超出当下回文区间之后不具备此条由回文区间带来的性质。</p>
<p>利用最大回文半径的赋值，可以复用比较结果，以此优化时间复杂度</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>从前向后遍历结点，只要当下结点还没有抵达或者超越当下回文区间边界，就可以尝试用其对称结点的最大回文半径赋值。<br>只要当下回文区间不能包含住结点的回文区间，那么当下的回文区间已经不可能再为当下结点已经后续结点提供回文半径赋值的性质，所以将当下回文区间转移为当下结点的回文区间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> Center = <span class="number">0</span>, Right = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*lenth<span class="number">+1</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;Right) <span class="comment">//由于0号为特殊元素不可能加入回文区间，回文左端点最左为1，i&lt;Right时，2*Center-i必然大于0，数组不会越界</span></span><br><span class="line">		r[i] = r[<span class="number">2</span>*Center-i] &lt; Right-i ? r[<span class="number">2</span>*Center-i] : Right-i;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		r[i] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(s[i+r[i]]==s[i-r[i]])</span><br><span class="line">		r[i]++;</span><br><span class="line">	<span class="keyword">if</span>(i+r[i]&gt;Right)</span><br><span class="line">		Center = i, Right = i + r[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.countingstars.cc/2024/09/03/Manacher%E7%AE%97%E6%B3%95/" data-id="cm0mgvkge0000j9to1yqmcwg2" data-title="Manacher算法" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-模式匹配算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/03/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2024-09-03T13:25:25.000Z" itemprop="datePublished">2024-09-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/03/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/">模式匹配算法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在 s1 中寻找 s2，暴力算法在遇到字符不匹配的时候会令 s2 回溯到起点，s1 回溯到起点后面一格</p>
<table>
<thead>
<tr>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">C</th>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">C</th>
<th align="center">D</th>
<th align="center">H</th>
</tr>
</thead>
<tbody><tr>
<td align="center">A</td>
<td align="center">B</td>
<td align="center">C</td>
<td align="center">E</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>这里发生失配，然后 j（s2 的元素指针）回溯到 0，i（s1 的元素指针）回溯到 1</p>
<table>
<thead>
<tr>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">C</th>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">C</th>
<th align="center">D</th>
<th align="center">H</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center">A</td>
<td align="center">B</td>
<td align="center">C</td>
<td align="center">E</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>显然这种回溯方式做了许多多余比较，<strong>KMP</strong>做法则是根据<strong>next</strong>数组做回溯</p>
<table>
<thead>
<tr>
<th align="center">C</th>
<th align="center">B</th>
<th align="center">C</th>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">C</th>
<th align="center">D</th>
<th align="center">H</th>
</tr>
</thead>
<tbody><tr>
<td align="center">C</td>
<td align="center">B</td>
<td align="center">C</td>
<td align="center">E</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>发生失配后，j 从 3 回溯到 1</p>
<table>
<thead>
<tr>
<th align="center">C</th>
<th align="center">B</th>
<th align="center">C</th>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">C</th>
<th align="center">D</th>
<th align="center">H</th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">C</td>
<td align="center">B</td>
<td align="center">C</td>
<td align="center">E</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><h4 id="前后缀"><a href="#前后缀" class="headerlink" title="前后缀"></a>前后缀</h4><p>字符串的前缀是从以第一个字符开始，任意元素结尾（除了字符串末尾元素外）组成的字符串的子字符串，字符串的后缀是以最后一个字符为结尾，任意字符（除了字符串起始元素外）开始的子字符串，相等的前缀和后缀的最大长度为最大相等前后缀长度，如果原字符串只有 1 个字符，最大相等前后缀长度视作 0</p>
<h3 id="求-next-数组"><a href="#求-next-数组" class="headerlink" title="求 next 数组"></a>求 next 数组</h3><p>从上面的表格可以看出，假如 s2 从 i 号跳转到 j 号，必须保证从 j 向前到开头的这一部分和从 i 向前相同长度的这一部分是完全相同的，也就是说 i 前面的一段字符串的最长相等前后缀的前缀的末尾的后面一位就是 j，由前缀的性质可知，j 同时也表示 i 之前的字符串的最大相等前后缀长度</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>;</span><br><span class="line">next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;s<span class="number">2.l</span>ength()<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(j==<span class="number">-1</span> || s2[i]==s2[j]) <span class="comment">//i之前最大相等前后缀长为0，那么j就会为-1</span></span><br><span class="line">	&#123;</span><br><span class="line">		i++,j++; <span class="comment">//相当于是对进入循环的i+1的回溯数组赋值，所以i只需要遍历到小于s2.length()-1</span></span><br><span class="line">		next[i] = j;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		j = next[j];</span><br><span class="line">		<span class="comment">//相当于是用j向前一直到起点的字符串来匹配i向前等长的字符串，匹配失败就回溯</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Kmp-主程序"><a href="#Kmp-主程序" class="headerlink" title="Kmp 主程序"></a>Kmp 主程序</h3><p>求出 next 数组之后只需要将 s2 与 s1 逐个字符匹配，如果失配，就让 s2 按照 next 数组回溯</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回第一次匹配成功的起点</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;s<span class="number">1.l</span>ength())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>( j==<span class="number">-1</span> || s1[i]==s2[j])  <span class="comment">//s2中没有元素可以匹配到s1[i]那么j就会为-1</span></span><br><span class="line">		&#123;</span><br><span class="line">			i++,j++;</span><br><span class="line">			<span class="keyword">if</span>(j==s<span class="number">2.l</span>ength())</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			j = next[j];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(j==s<span class="number">2.l</span>ength())</span><br><span class="line">		<span class="keyword">return</span> i - j ;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>

<h3 id="瑕疵与优化"><a href="#瑕疵与优化" class="headerlink" title="瑕疵与优化"></a>瑕疵与优化</h3><p>考虑 s1 &#x3D;&#x3D; “aaaaaaaabaaaaac” s2 &#x3D;&#x3D; “aaaaac”的情况，c 失配后回溯到 4 号 a，又失配，回溯到 3 号 a，然后回溯到 2 号 a…. 一直到 0 号 a 失配，回溯到-1，同一个字符失配过一次后就不需要再尝试匹配，在求 next 的过程中，加入判断语句，判断失配元素与其回溯元素是否相等，若相等，就将回溯元素的回溯元素传递给失配元素</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>;</span><br><span class="line">	next[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;s<span class="number">2.l</span>ength()<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(j==<span class="number">-1</span> || s2[i]==s2[j])</span><br><span class="line">		&#123;</span><br><span class="line">			i++,j++;</span><br><span class="line">			<span class="keyword">if</span>(s2[i]!=s2[j])</span><br><span class="line">				next[i] = j;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				next[i] = next[j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			j = next[j];</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AC-自动机"><a href="#AC-自动机" class="headerlink" title="AC 自动机"></a>AC 自动机</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>字典树与 KMP 的结合，用于模式串过多，字典树运行时间过长的情况</p>
<h3 id="代码逻辑"><a href="#代码逻辑" class="headerlink" title="代码逻辑"></a>代码逻辑</h3><ul>
<li>AC 自动机下标 0 为特意设定的头结点</li>
<li>回溯数组的求法：让每个模式串的首字母回溯到 0，每一个结点 x 都回溯到与其存储相同字母的结点 bk，bk 父结点为 x 父结点的回溯结点，因为回溯的结点要么是 0 结点，要么是和自己存储相同字母的结点，所以从 bk 走到 0 的字符串必然和 x 走到 0 过程中经历相同长度的字符串的内容相同</li>
</ul>
<h3 id="核心代码-自动机结构体"><a href="#核心代码-自动机结构体" class="headerlink" title="核心代码_自动机结构体"></a>核心代码_自动机结构体</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> bk; <span class="comment">//回溯结点</span></span><br><span class="line">    <span class="type">int</span> cae;  <span class="comment">//以此结点为终点的单词个数</span></span><br><span class="line">    <span class="type">int</span> letter[<span class="number">26</span>]; <span class="comment">//起始结点为当下结点，下标表示两结点之间对应的字母，值表示终止结点</span></span><br><span class="line">&#125;AC[maxn];</span><br></pre></td></tr></table></figure>

<h3 id="核心代码-建立字典树"><a href="#核心代码-建立字典树" class="headerlink" title="核心代码_建立字典树"></a>核心代码_建立字典树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BuildTrie</span><span class="params">(<span class="type">const</span> std::string&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!AC[x].letter[s[i]-<span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">			AC[x].letter[s[i]-<span class="string">&#x27;a&#x27;</span>] = ind++; <span class="comment">//ind为字典树组栈顶指针</span></span><br><span class="line">		x=AC[x].letter[s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	AC[x].cae++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="核心代码-求回溯数组"><a href="#核心代码-求回溯数组" class="headerlink" title="核心代码_求回溯数组"></a>核心代码_求回溯数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetBtk</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	std::queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(AC[<span class="number">0</span>].letter[i])</span><br><span class="line">		&#123;</span><br><span class="line">			AC[AC[<span class="number">0</span>].letter[i]].btk=<span class="number">0</span>;</span><br><span class="line">			q.<span class="built_in">push</span>(AC[<span class="number">0</span>].letter[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> cur=q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(AC[cur].letter[i])</span><br><span class="line">			&#123;</span><br><span class="line">				AC[AC[cur].letter[i]].btk = AC[AC[cur].btk].letter[i];</span><br><span class="line">				q.<span class="built_in">push</span>(AC[cur].letter[i]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>  <span class="comment">//防止因为走的路径问题错过本来可以匹配的对象</span></span><br><span class="line">				AC[cur].letter[i] = AC[AC[cur].btk].letter[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="核心代码-字符串匹配"><a href="#核心代码-字符串匹配" class="headerlink" title="核心代码_字符串匹配"></a>核心代码_字符串匹配</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">AC_Query</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> cur=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++) <span class="comment">//遍历文本串的每一个字母</span></span><br><span class="line">	&#123;</span><br><span class="line">		cur = AC[cur].letter[s[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> t=cur;t&amp;&amp;AC[t].cae!=<span class="number">-1</span>;t=AC[t].btk) <span class="comment">//回溯的时候到了0就终止，如果cae等于-1说明此路来过</span></span><br><span class="line">		&#123;</span><br><span class="line">			ans += AC[t].cae;</span><br><span class="line">			AC[t].cae = <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.countingstars.cc/2024/09/03/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/" data-id="cm0mgqh7a00010bto73g7bkdc" data-title="模式匹配算法" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-javaScript的this" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/03/javaScript%E7%9A%84this/" class="article-date">
  <time class="dt-published" datetime="2024-09-03T13:22:08.000Z" itemprop="datePublished">2024-09-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/03/javaScript%E7%9A%84this/">javaScript的this</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h3><p>普通函数直接调用则 this 绑定全局变量，严格模式下，this 绑定到 undefined</p>
<h3 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h3><p>函数作为对象的属性调用则会将 this 隐式绑定到这个对象</p>
<h4 id="正常绑定"><a href="#正常绑定" class="headerlink" title="正常绑定"></a><strong>正常绑定</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">42</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo,</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="title function_">foo</span>(); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>

<h4 id="引用导致-this-丢失"><a href="#引用导致-this-丢失" class="headerlink" title="引用导致 this 丢失"></a><strong>引用导致 this 丢失</strong></h4><p>在上面的例子中，如果给函数一个别名<code>var bar = obj.foo</code> 这个时候它引用的是函数本身，如果这样调用<code>bar()</code>就相当于在全局的位置调用 foo 函数。</p>
<h4 id="传参过程-this-丢失"><a href="#传参过程-this-丢失" class="headerlink" title="传参过程 this 丢失"></a>传参过程 this 丢失</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doFoo</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="title function_">fn</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">doFoo</span>(foo);</span><br></pre></td></tr></table></figure>

<p>即便是传入 js 内置函数也会发生 this 丢失，比如 setTimeout 等</p>
<h5 id="组件传参防止-this-丢失"><a href="#组件传参防止-this-丢失" class="headerlink" title="组件传参防止 this 丢失"></a>组件传参防止 this 丢失</h5><p><strong>传入的函数</strong></p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">lockedScale</span> = (<span class="params"><span class="attr">scale</span>: <span class="built_in">number</span></span>) =&gt; &#123;</span><br><span class="line">  controller!.<span class="title function_">lockedScale</span>(scale); <span class="comment">//在这里确保了是让controller调用这个函数，不会丢失this</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>传入组件</strong></p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">InputSlider</span> draging=&#123;lockedScale&#125; /&gt;</span><br></pre></td></tr></table></figure>

<h3 id="显示绑定"><a href="#显示绑定" class="headerlink" title="显示绑定"></a>显示绑定</h3><ul>
<li>apply 为函数设置绑定的 this，然后调用它</li>
<li>bind 为函数设置绑定的 this，然后返回一个新的函数，但是不会调用它</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.countingstars.cc/2024/09/03/javaScript%E7%9A%84this/" data-id="cm0mglprm0000mito20p00bim" data-title="javaScript的this" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-React三大Hook" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/09/03/React%E4%B8%89%E5%A4%A7Hook/" class="article-date">
  <time class="dt-published" datetime="2024-09-03T13:08:41.000Z" itemprop="datePublished">2024-09-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2024/09/03/React%E4%B8%89%E5%A4%A7Hook/">React三大Hook</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h3><p>对<code>state</code>的设置是异步的，不能及时获取</p>
<p>如果需要确保随机的两次是完全不同的，需要用 ref</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> preInd = useRef&lt;<span class="built_in">number</span>&gt;(-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> curInd = useRef&lt;<span class="built_in">number</span>&gt;(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handleRandom</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> n = <span class="number">11</span>;</span><br><span class="line">  <span class="keyword">const</span> randomTexts = <span class="title class_">Array</span>.<span class="title function_">from</span>(&#123; <span class="attr">length</span>: n &#125;, <span class="function">(<span class="params">_, index</span>) =&gt;</span></span><br><span class="line">    <span class="title function_">t</span>(<span class="string">`prompt:prompt_text_random<span class="subst">$&#123;index + <span class="number">1</span>&#125;</span>`</span>)</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  curInd.<span class="property">current</span> = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * n);</span><br><span class="line">  <span class="keyword">while</span> (curInd.<span class="property">current</span> === preInd.<span class="property">current</span>) &#123;</span><br><span class="line">    curInd.<span class="property">current</span> = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * n);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  textRef.<span class="property">current</span> = randomTexts[curInd.<span class="property">current</span>];</span><br><span class="line">  <span class="title function_">setTextState</span>(randomTexts[curInd.<span class="property">current</span>]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><p><strong>ref 可以确保变量是最新值，不会重新渲染页面，如果需要获取最新值而且需要实时渲染，那么就要结合<code>useState</code>使用</strong></p>
<h3 id="综合应用"><a href="#综合应用" class="headerlink" title="综合应用"></a>综合应用</h3><h4 id="useState-注解"><a href="#useState-注解" class="headerlink" title="useState 注解"></a>useState 注解</h4><p>定义：<code>const [textState, setTextState] = useState&lt;string&gt;(&#39;&#39;)</code><br>传入子组件的注解：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">textState</span>: <span class="built_in">string</span>;</span><br><span class="line"><span class="attr">setTextState</span>: <span class="title class_">React</span>.<span class="property">Dispatch</span>&lt;<span class="title class_">React</span>.<span class="property">SetStateAction</span>&lt;<span class="built_in">string</span>&gt;&gt;;</span><br></pre></td></tr></table></figure>

<h4 id="useRef-注解"><a href="#useRef-注解" class="headerlink" title="useRef 注解"></a>useRef 注解</h4><p>定义：<code> const textRef = useRef&lt;string&gt;(&#39;&#39;)</code><br>传入子组件的注解：(MutableRefObj 表示这个 ref 是一个可以修改 current 的 ref)</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">textRef</span>: <span class="title class_">MutableRefObject</span>&lt;<span class="built_in">string</span>&gt;;</span><br></pre></td></tr></table></figure>

<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p><strong>需求：用户输入的文本框实时更新，输入的内容要被用作输入词调用 SD</strong><br><strong>解决方案：用 state 渲染输入的内容，用 ref 传给 SD</strong></p>
<h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3><p>用空数组监听的时候常常监听不到，这是因为挂载和卸载的触发比较严苛，用逻辑表达式决定组件出现与否的时候会触发组件的挂载和卸载</p>
<p>组件挂载和卸载只发生在 DOM 结构中添加和删除组件的时候，Dialog 的 open 与否不会导致挂载和卸载。</p>
<p>state 变量改变，以及 zustand 变量改变的时候则会触发整个组件的所有代码重新执行，但是也不会导致挂载和卸载</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.countingstars.cc/2024/09/03/React%E4%B8%89%E5%A4%A7Hook/" data-id="cm0mgqh7800000bto0asu7myf" data-title="React三大Hook" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/09/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E8%B5%84%E6%BA%90%E4%BC%98%E5%8C%96%E7%89%88%EF%BC%89/">动态规划（资源优化版）</a>
          </li>
        
          <li>
            <a href="/2024/09/03/%E5%9B%BE%E8%AE%BA/">图论</a>
          </li>
        
          <li>
            <a href="/2024/09/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E5%AD%90%E9%97%AE%E9%A2%98%E6%9C%80%E4%BC%98%E8%A7%A3%E9%80%92%E6%8E%A8%EF%BC%89/">动态规划（子问题最优解递推）</a>
          </li>
        
          <li>
            <a href="/2024/09/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
          </li>
        
          <li>
            <a href="/2024/09/03/Manacher%E7%AE%97%E6%B3%95/">Manacher算法</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 Lios<br />
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>